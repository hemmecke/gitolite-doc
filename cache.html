
<head>
    <title>gitolite and the (redis) cache</title>
<style>
    body        { background: #fff; text-color: #000; margin-left:  40px;   font-size:  0.9em;  font-family: sans-serif; max-width: 800px; }
    h1          { background: #ffb; text-color: #000; margin-left: -30px;   border-top:    5px  solid #ccc; }
    h2          { background: #ffb; text-color: #000; margin-left: -20px;   border-top:    3px  solid #ddd; }
    h3          { background: #ffb; text-color: #000; margin-left: -10px; }
    h4          { background: #ffb; text-color: #000; }
    code        { font-size:    1.1em;  background:  #ddf; text-color: #000; }
    pre         { margin-left:  2em;    background:  #ddf; text-color: #000; }
    pre code    { font-size:    1.1em;  background:  #ddf; text-color: #000; }
</style>
</head>

<p style="text-align:center">
    <a href="master-toc.html">master TOC</a>
|
    <a href="index.html">main page</a>
|
    <a href="index.html#license">license</a>
</p>
<p style="text-align:center">
<font color="gray">This is for gitolite "g3"; for older (v2.x) documentation click <a href="http://sitaramc.github.com/gitolite/g2/master-toc.html">here</a></font>
</p>
<h1>gitolite and the (redis) cache</h1>

<p>There's now a branch of gitolite called "redis" that uses the Redis in-memory
key-value database to speed up some parts of gitolite.</p>

<p>To install it, just install redis, then the perl driver "Redis.pm".  Then
install this branch of gitolite in the normal manner.  Redis will start
automatically and the right things will happen (but see caveats below).</p>

<p>Support for this branch is limited to verifiable gitolite bugs, if you find
any; I can't help you with redis itself.</p>

<hr />

<p>First, the warnings/caveats.  If you ever kill the redis-server be sure to
also remove the socket file <code>~/.redis-gitolite.sock</code>.  Conversely if you ever
remove the sock file be sure to kill the process also.  Otherwise you get
weird behaviour, including possible hangs.</p>

<p>(To the best of my knowledge, this cannot result in wrong data being passed to
gitolite, causing a security breach.  If anyone has time I'd appreciate a
review of the code -- it's not too big, the diff is only about 180 lines, and
most of that is a new file of 140 or so lines).</p>

<h2>details</h2>

<p>During normal operation, (i.e., normal user executing a normal git operation
on a repo), there are a couple of places where gitolite is somewhat wasteful,
because each run, being a separate program, recomputes the same things.</p>

<p>The first is the parsing of the "gitolite.conf-compiled.pm" file, which
contains all the access rules that pertain to repo groups or repo patterns
(i.e., not to any particular repo specifically).  If that file is large, there
could arguably be several rules in it that do <em>not</em> pertain to the current
repo, and are a waste of time to parse.</p>

<p>Worse, for write operations this whole thing happens again, since the update
hook is, for all practical purposes, a completely separate program.</p>

<p>The second is the code that generates the list of rules that apply to <em>this</em>
user on <em>this</em> repo.  Consider something like this:</p>

<pre><code>repo foo
    RW              =   alice
    RW+ dev/USER/   =   @staff
    RW  refs/tags/  =   @QA
    -               =   @interns
    RW+             =   @staff
</code></pre>

<p>Depending on which of the 3 groups Alice is a member of, anything from 1 to 5
rules actually <em>apply</em> to her, and the rest don't.  Determining the ruleset
for a specific user-repo combination <em>does</em> take some code.</p>

<p>So what gitolite does is simply cache the ruleset for every repo-user
combination that is access-checked.  That's it.  The next time the same user
tries to access the same repo, all that code is bypassed.</p>

<p>On my laptop, the figures are 150 milliseconds versus 0.6 milliseconds.
The ssh connection and perl startup are about 200 + 80 millisecond
respectively, you've shaved 33% off of each read attempt, and 50% off of each
write!</p>

<p>Across tens of thousands of access attempts, this adds up!  And the longer the
system is up, the higher the hit-rate, which is great!</p>

<p>That's the <strong>good news</strong>.</p>

<p>The <strong>bad news</strong> is that there are some situations in which the cache is
flushed, bringing your system back to square one.</p>

<ul>
<li><p>every time 'gitolite compile' runs (e.g., when you push the admin repo)</p>

<p>So if frequent pushes to gitolite-admin are the cause of your problem,
this won't help you.  In fact, it'll make it worse, because any access
that misses the cache now takes <em>more</em> time than before (the normal time,
plus time to deal with the caching software/API).</p></li>
<li><p>every time the owner of a wild repo touches the gl-perms file, all rules
for this specific repo are flushed (not the entire cache, though so that's
not too bad).</p></li>
<li><p>finally, and worst of all, if you have defined an external program
(<code>GROUPLIST_PGM</code>) to supply a list of groups a given user belongs to, all
cache entries are only saved for 60 seconds, instead of the normal 9999
seconds (just over a day).  This is because there is no way to tell what
group a user may be in from one minute to the next, and if his group list
changes, so does the ruleset.</p>

<p>You can set <code>CACHE_TTL</code> in the rc file to some larger value if you know
that your external group list data does not change that often, or that
when it does, it's ok to run with a stale group list for a user for some
time.</p></li>
</ul>
